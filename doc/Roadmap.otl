Roadmap
-------

FreeCAD: Model rings (parametrically) and then create jigs to hold them


Modify queue to automatically move to next job once current job ends
Add recipe parser to automatically put jobs in queue

[_] Generate and laser a ring from Python (move/resize GalvoGroupShadow101 and repeat. Queue layers up inside the XML and then get lmos to call them in sequence)
	Generate an array of shadows
		: Layers are shadows. All objects on that layer are marked within that
		: shadow.
	Split geometries at shadow boundaries
	For each layer
		Activate that layer and deactivate all others
		Move the shadow into position
		Start marking
		Wait for finished marking signal
[_] Generate and laser a ring from Inkscape SVG Library
	Load Inkscape SVG
	Create objects
		: Line, arc, text, layer, shadow, laser parameter, ring
		: feature
	Export to Rofin XML
	Very fast change to laser parameters/number of passes or layer height from inkscape
	Very visible status within Inkscape - bright colours to show enabled/disabled and laser parameters
		: Maybe use filter so that a change to colour or fill will
		: automatically update.
[_] Inkscape break discrete paths into shadow parts where possible to avoid breaks
	For all objects smaller than a shadow width
		Find the biggest remaining object
		Group that object and all objects that can lie within it
		Calculate the leftmost and rightmost shadow edges that could mark those objects
		Find the largest remaining object that fits within those edges but does not lie in both
		Add it to the group and shrink the left or right edge to accommodate
		Repeat
[_] Ring calibration line generator with letters/numbers
[_] Ring calibration decoder and shadow creator
[_] Multicast reply (needed to signal when shadow is finished)
[_] Stagger shadows by number of passes
	This is only needed on seamless drawings, where the joins cannot be avoided. Otherwise, just split at the individual paths.
[_] Jupyter control
	Generate SVG for display in Jupyter
	: https://matplotlib.org/gallery/#d-plotting
[_] Multicast server locator
[_] SVG simplify / decompose to lines and arcs
	Clipper library to merge/offset polygons
		: Ramer-Douglas-Peucker but arcs instead of lines using least squares
		: Look at Inkscape Gcodetools
		: Iterate through paths
		: Break up every section into a separate entity
		: Convert bezier sections into biarcs
	SVG remove duplicates
	: http://www.ryanjuckett.com/programming/biarc-interpolation/
	: https://en.wikipedia.org/wiki/Biarc
	: https://emergent.unpythonic.net/01171767993
	: https://github.com/joedski/arcfit-bezier-spline-qcad
[_] Recognise (similar to Inkscape recognise plugin)
	: Nearly horizontal/vertical lines
	: Recognise arcs and circles
	: Move items to nearest grid
[_] Import and Export FreeCAD
[_] Acam to SVG
[_] SVG to acam
[_] NuLOOQ to manipulate SVG with realtime Tripmine update
	Common Python library for both FreeCAD and Inkscape
[_] OpenCV + Zbar for qrcode recognition



SVG String
	Loop through paths
		Does path contain any bezier or non-circular elliptical arc segments?
		If so:
			Explode path
			Convert bezier sections to circular arcs
		Otherwise:

Components
	Acam
		: Basic plugin to send and receive drawing data from the tentacle
		: server
	Blastpit
		: Geometry, SVG, network and Octave library. The blastpit class
		: contains an SVG document that holds all geometries and settings.
	FreeCAD
	Inkscape
	BlastpitGui
		: NuLOOQ driver, compute engine and input/output forms. Contains an
		: instance of the blastpit class to hold the current job.
	Testchamber
		: Unit tests
	LMOS
		: LMOS driver. Should be as simple as possible - all computation done
		: on the blastpitgui server.

References

Use xdotool to automatically reload the preview in Inkscape


Calibration Overview

The output of the calibration process is an array of shadows, each comprising the start X coordinate and the width, such that a line broken into individual sections placed into the shadows would result in a single unbroken line.

Due to non-circular geometry of the ring, or non-linearity of the rotary axis, the shadows may not meet or may overlap.


TDD
---

What are the requirements to test 'x'? 
	What does the object do?
	How does it interact with the data or hardware it controls?
	How can we make it testable?

start blastpitgui

start inkscape
create drawing
click apply
inkscape sends the svg to blastpitgui, which stores it as the blastpit object
blastpitgui runs the svg2bezier converter
(convert laser.py to c++)
send to lmos

listen for nulooq 
convert to geometry translations
update xml
when complete, send back to inkscape



Issues
------

When first sending a program after all machines were turned off over the weekend, the inkscape script gives an error (socket timeout) after managing to send a few commands to lmos. Running it again and it works.


Class List
----------

m = method, p = property, l = list

Blastpit
	Parser
		Network
		Lmos
	Drawing
		mImportSvg (parses SVG and build database)
		mExportSvg (constructs SVG from database)
		pConvex/Concave
		pDiameter
		pJig Angle
		lRecipes
			Recipe
		lShadows
			Shadow
				pZHeight
				pPosition
				pSize
				lPaths
					Path
		lCalibrationMap
			: A calibration map maps a 2d x,y point of the drawing to a 4d
			: x,y,z height, rotation r  point.


Network -> Send packet to other Network
Network receives packet, stores it and replies ack/nack based on checksums.

Network passes to parser
Parser checks if new command is waiting on old command to finish
If so, parser sets signal/slot to wake up on lmos message, and returns
	: Not neccesary. The parser should be called by a signal/slot after every
	: command completion.
Parser calls Lmos
Lmos runs command and returns to parser
Parser stores reply in Log class and emits logEntry(id) signal
Parser sends reply to Network 
Network sends reply back to caller on same connection

Note: Parser calls Lmos, and can block without issue because Network will queue packets while waiting.
Network cannot be allowed to block until parser finishes, because parser may hit long-running lmos?

Clients can call getLogEntry(id) to check if their command has completed successfully.

Log object: Stores every network packet id, along with 


How do we deal with signalling back to Inkscape/FreeCAD that a command has
finished? Do we leave the network connection open for all commands that have
not finished yet? Or does the client have to poll?



Convert everything to TDD
Convert as much code to C as possible. Use assertions
Move away from Qt for library code where possible
Fuzz using AFL

Add return codes to all lmosactx calls from lmos, where possible
Add all return codes and signal return codes to parser log
Add function to check from log if parent completed successfully

Cylinder marking, with queued shadows and feedback from lmos signals
NuLooq
Lua/Swig

Test harness contains features
Unit tests test those features
Tests test against the feature requirements, not against the code structure

Hardware TDD
------------

Create a thin layer that works against the actual hardware, and test it against the hardware to ensure that it works.
Create a mock that has the same functions and interface as the thin layer.



There are only three optimizations: Do less. Do it less often. Do it faster. The largest gains come from 1, but we spend all our time on 3.



<recipe>
mark layer1, layer2
rough using 4 passes with setting silver and hatch standard
skim using 1 pass with setting cleaning
mark layer3
rough using 1 pass with setting silver and hatch standard
skim using 1 pass with setting fine clean
</recipe> 





Think of ways that we can speed up fine-tuning of position
==========================================================

Is the 'upload to laser' command necessary?

Select 'positioning help':
	Compile list of all geometries that are on visible layers with height
	Exclude any geometries falling outside of 0,0 -> 120,120
	Convert geometries to simplified versions and keep track
	Upload
	Activate positioning help, which should show the bounding box of all paths by default
	NuLOOQ jog wheel cycles through the list of paths, showing simplified outline
	When the centre (II) button is pressed and released, the NuLOOQ changes state:
		The last selected object is now shown in more detail
		NuLOOQ grey ring manipulates the geometry
		Holding a finger on the centre (II) button while rotating the
			grey ring scales inward or outward.
		Jog wheel revolves positioning help around perimeter of shape. By
			default, one circle of the ring corresponds to one circle of
			the perimeter of the shape. Pressing left (I) or right (III)
			decreases or increases the level of detail
		A warning is shown (perhaps flashing leds on NuLOOQ or by showing a rectangular bounding box with a cross through it) if the current
			height (as told by RCU) does not match the layer height. This can
			be caused by attempting to display items with the door open, which
			prevents the height from adjusting automatically. It may be possible to
			manually adjust it
	Pressing the bottom button (O) exits the positioning help, and sends
		back any changes to the geometry.  Use setdimension() to scale the
		width/height, and setposvalues to modify the position and rotation

Allow easy (one-click?) repeat cut and repeat clean, possibly from the NuLOOQ
	(by depressing the main centre button cluster?)



Alphacam
--------

Connect: Initiate connection to server and activate listening loop
ReceiveLoop: Receive discrete packets (no state) and process. Can be one of:
	AddEntities: Add database entries to drawing
		CreateLayer:
		SetLayerProperties:
	DeleteEntities: Delete database entries from drawing. Can be 'All'.
	UploadAllEntities: Convert whole drawing to XML database and send to server

SendCommand: All acam toolbar buttons just map to this
SendPacket: Connect to ReceiveLoop and send packet (with LZ4 eventually)

GetHighestId:	Loop through all entities and find the highest Id.


Blastpit Library
----------------

DatabaseCompare: Compare two databases and return a database of additions and a database of deletions
GenerateID: Take a database and return a new unique ID

===============================

Tentacle
--------

System tray network server and geometry engine, communicating with client
programs and the tripmine server

Tripmine
--------

Laser controller, receiving commands from tentacle server and sending status
replies

Test Driven Development
-----------------------

Write a test
Check that it fails but existing tests pass
Write code
Check that all tests now pass
Clean up code

Documentation
-------------

Document the build tools files as well (such as sip files) because we will
forget how to use them



We need an icon of the laser mine for tripmine

Battle Plan
	Tools
		Setup youcompleteme and get it working properly with omnicomplete and snippets
		Setup ctags
		Setup fugitive
	Overall Design
		Break the task into programs that could be piped like unix
	Program Design
		Break the programs into functions that can be piped

Laser Controller (bplaser)
	Initialise systray
	Initialise laser
		: Create the laser object and pass a pointer to the network class
		: which will listen for commands from the server and send them to
		: the LMOS control
	Initialise cameras
	Network server
		Create socket
		Listen for connection (signal/slot)
		ReceiveCommand (wait for command + data)
			: Allocate buffer to hold command (uint16)
			: Read 2 bytes from socket (implement generic read command)
			: Parse the command
			: Call a function based on the command (function pointer?)
			: * the function can use get + put commands to speak
			: a dialogue with the client until the command is complete.
			InitMachine
			ClearLayout
			ImportXMLFile
			StartPosHelp
			StopPosHelp
			StartMarking
			StopMarking
			NewPos
			MoveAxes
			(camera) Capture image
		Send reply
			Return data
			Inform blastpit server of current state of laser and hardware
				state = GetLaserStatus()
				SendServer( state )

Blastpit Server (bpserver)
	Connect to bpLaser server
	Listen
	Receive request
	Parse request
	Loop
		Request input
			GetPoint(client)
			GetPath(client)
			GetPaths(client)
			UpdateDatabase(client) - Gets all geometries
		Recieve input
		Process data
		Send output
			Convert G-Code to XML
			DeletePath(client)
			AddPath(client)
			AddLayer(client)
	Maintain connections with addins, Qt and laser
	(optional) Control laser camera and vision system

AlphaCAM Add-In (bpacam)
	Connect to server
		ConnectNetwork() {
			int maxTries = 10;
			do
				SendBroadcast(enum role)
				serverIP = ListenBroadcast( int timeout )
			while (serverIP == null && maxTries > 0)
		}
		if( serverIP ) {
		socket=ConnectSocket(serverIP)
	(thread) Listen for requests
		cmd-and-data = ListenServer(socket)
	Perform specified actions
		ParseAction( int command )
			case(command)
			CreatePath( data )
				# if data = circle only then CreateCircle
			CreateLayer( data )
			CreateText( data )
			DeletePath( data)
			DeleteLayer( data )
			DeleteText( data )
	Return data
		data = PickPoints( serverRequest, numPoints )
		data = PickPaths( serverRequest, numPaths )
		data = PickText( serverRequest, numTexts )
		data = GetCurrentDrawingDatabase()
		SendServer( data )
	(optional) Toolbars and sending commands

Python bindings (bppython)
	FreeCAD
	IPython
	Inkscape
	Blender

Common Networking/Messaging Class (bpnet)
	: Must be c++ class due to being used everywhere
	int SendBroadcast(packet)
		: Sends a broadcast packet to the local subnet
		: Returns false if a network error occurs
	int ListenToBroadcast(&packet, packettype, timeout)
		: Waits <timeout> seconds for a packet of type <packettype>
		: Returns false if no packet found or an error occurs
	ListenToServer()
	ConnectNetwork()
	ConnectSocket()
	SendToServer()

Testing Framework
	cppunit
	build a log into every application

Documentation to read
	FreeCAD Python Lines Arcs Output
	Inkscape

Programs
	FreeCAD
		Opencascade documentation
	Inkscape
	IPython from console and notebook
	Sympy for symbolic math in python
	Cgal/Ipython for boundaries/hatching/offset etc
	pytables
	Blender
	Ncurses caldav (libcaldav)
	Spacenav/NuLooq
	Postgres for big data
	Cunit/Cppunit/python unittest module
	Meshlab

3D Lasering
	First, divide the height of the object up into focal slices
	Then, for each path, follow the path and break it up at the points at which
	it moves between slices. Assign each break to the respective Z layer

TODO
	Laser -> Auto switch to positioning help when job is done for repetitive jobs, so that we can quickly remove the part and drop the next part in the marked position
	Fast Text -> Laser
	3D Sculpting (blender) -> Laser
	3D Lasering in general from FreeCAD
	Fast pickup of position/outline using camera or vernier dots
	Super CAD Centre - join all programs together (inkscape, blender, freecad, acam & laser)
	FreeCAD taper check/G51-G52 verifier
	FreeCAD to G Codes
	Reverse Engineer the Roland Scanner
	Sequential Numbering
	Reducing Setup Times

FreeCAD views to alphacam with duplicate line and arc removal
	FreeCAD select connected paths for simplified 4-axis output
	FreeCAD warn on taper

Problems and Solutions
	3D Shapes
		3D Scanner (Roland)
		3D Laser software
	Burned through thin metal
		Test depth of cutting in various metals and record
		Measure thickness beforehand
	Bitmap not cutting as displayed
		Convert bitmap into lines
		Control laser directly
	Time taken to convert James Newman
		Inkscape plugin to partially automate
	James Newman holes not drilled exactly to drawing
		Use 3d scanner or laser to digitise holes















Break inkscape drawing up into individual laserable objects (compound shapes)
break any objects larger than a shadow at the best (narrowest?) point and automatically create the shadows
Calculate shadows
	Sort all objects by start point
	For each object:
		If object falls within a shadow created above then add to that shadow and remove from list. Don't update count
		Calculate end point of shadow started on that object
		Count all objects that lie within that shadow
	Create shadow with largest count
	Remove those objects from list
	Repeat
put objects into shadows (layers)
for each layer: upload layer objects, start marking, etc.

::::::::::::::::
:  Components  :
::::::::::::::::

Recogniser
	Recognises item from image
		Input: CV dataset, Bitmap from camera
		Output: Table of confidence that item is within dataset
		Output: Position and orientation of item

GUI
	Allows choice of item, customer
		Input: Manual drop-down box / External signal from recogniser
		Input: Manual measurement of item / Laser digitised measurement
		Output: GUI information about item
		Output: FreeCAD or Blender 3D model real-time update
		Output: Inkscape 2D model real-time update

:::::::::::::::::
:  Ideal Setup  :
:::::::::::::::::

1) GUI with fast access to templates for common jobs and customers, and recording of completed job
2) Computer vision and machine learning for fast setup, calibration, and removal of need to open door
3) Integration with Inkscape, FreeCAD and blender for immediate visualisation of job and positioning
4) Hardware control for fast operation (touchscreen, NuLOOQ, fpga)

M: = Manual / A: = Automated

Unpack item from customer

M:
A:
	Place in camera view
	Recogniser: Camera recognises item and displays GUI screen to choose customer and item
	: Requires a database of customers and products

Select type of marking application, e.g. simple text or fingerprint
GUI shows details of item, setup instructions, requests for measurement
	Can GUI be a web app or emscripten app running in a browser?
Gui updates to show instructions on where to put ink and how to position the item in the holder
Laser uses cameras, machine vision and positioning laser to digitise the item
	Use 3d reconstruction from photos
	: Requires control of all cameras, rotary axis and positioning laser,
	: with ability to coordinate over the network
Laser marks apriltags on item and cameras examine them to accurately position and calibrate
A 3d rendering opens up in Blender or FreeCAD
	: Requires the ability to construct a 3d representation of an item from the
	: digitised data, the ability to construct a 3d model to display the item,
	: and the ability to texture the item
A 2d model opens up in Inkscape, with sample text or fingerprint, and a template recipe for that application type
	: Requires the ability to construct a 2d model of the item, and the ability to
	: unwrap the photographs to a flat bitmap within Inkscape. Also, the
	: ability to generate shadows from the model.
User manipulates the Inkscape drawing, with updates in the 3d viewer
Select dry run in the gui
	: Requires blastpit positioning laser parsing and control.
	: Requires ability to calibrate positioning laser
	: Requires the Blastpit gui to parse recipes from Inkscape
Check position and modify if necessary
Use NuLOOQ to jog
Select full marking in gui
	: Requires blastpit laser marking and control.
Positioning laser or camera calculates depth of marking if possible
Auto take photo of completed job and enter into a database or spreadsheet, with a time entry in the remind calender
	: Requires database connection and better control of Openoffice macros.


::::::::::
:  Tips  :
::::::::::

Advice
	you will get it wrong, optimize for making your code easy to modify in the future

Notes
	\cb to create checkbox
	\cx to toggle
	\cd to delete

# vim: foldlevel=1 foldcolumn=5
