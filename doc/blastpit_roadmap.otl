	Quick Thoughts
		Features
			Fast setup
			Easy jogging

		In order for the Steam controller to be useful, we must have the ability to control the positioning laser 

		Laser a plate with Apriltags and digitise using the camera (at extremes 0mm and 120mm)
		Draw the same Apriltags using the positioning laser and digitise that
		Calculate the difference

		Open Inkscape Drawing
			Select group
				Generate bounding rectangle
				Upload to laser
				Start positioning help
				Listen for Steam controller
				Manipulate object until exit
				Return new coordinates and rotation to Inkscape



Battle Plan (Read every time)
	Tools (test after every system/neovim update)
		Setup coc and get it working properly with omnicomplete and snippets
		Setup ctags
		Setup vim debugger
	Program Design
		Top-down development
		: Continue decomposing until it seems that it would be easier to code
		: the next level than to decompose it.
		Imagine the function that you wish existed and write it.
		Break the task into programs that use STDIN/STDOUT pipes.
			: This enables fuzzing with afl.
	Software Development Principles
		Clean code
			: Make code as easy to read as possible
			: Descriptive variable names
			: Self-documenting code
		Use clang and lldb where possible
		Use sanitisers
		Use afl fuzzing
		Better Python debugging with Python-GDB
		Convert as much code to C and Zig as possible.
		Google Style Guide
			: Filenames: Lowercase with underscores, use .cc for c++ files
			: Types: Capital letter starting each word, no underscores.
			: Variables: All lowercase with underscores between words
			: Struct data members: Same as variables
			: Constants: Start with k, followed by capital word starts
			: Enums: Same as constants
	Test Driven Development
		Fundamentals
			Tests test against the feature requirements, not against the code structure
		What are the requirements to test 'x'? 
			What is the set of tests which, when passes, demonstrates that the code works correctly?
			What does the object do?
			How does it interact with the data or hardware it controls?
			How can we make it testable?
		Build unit tests in Zig wherever possible.
	Optimization
		Do less. Do it less often.
	Documentation
		Document the build tools files as well (such as sip files) because we will
		forget how to use them

MUST SEE SOMETHING
MUST SEE CHANGES
	Coloured output on terminal
	Web page updates
	LCD screen

We will need Freecad if we are going to be developing and designing products.
Sketching (in Inkscape) will also be very useful.

Programming Faster and Easier
	Keyboard shortcuts and macros for ErgoDox
	Window Manager (run new awesome in a window using that technology)
	Kitty
	Zsh
	Tmux
	Neovim
	SpaceMouse and NuLOOQ
		Needs multi-device support
		Fix extended buttons issue
		LCD menu generation

Blastpit Coding Roadmap
	Websockets as Protocol
		Move away from Mqtt to using websockets for faster data transfer
			Write Websockets tests in Zig
			: Parallel build of C and Zig websockets code
			Write Websockets server
				Standalone program
				Must be compatible with emscripten
	Skeleton Webapp
		Create the main control program as a web app using webassembly, webgl, and websockets
		Minimal webapp to act as replacement for current inkscape functions.
			: Parse SVG, extract paths, generate XML, upload via
			: Mqtt/websockets
			: Very visible status - colours show enabled/disabled or laser parameters
	[X] Remove Object-Oriented C
		[X] Refactor code to remove classes, or remake in Zig
	Controller Driver
		Driver for use with 3D mouse and Steam Controller, that sends info over websockets
	Lmos conversion
		Use qprocess to launch lmos, allowing for it to crash without crashing the main process
		Build with Qt, but link in code generated with Zig, etc.
			: Main logic written in Zig and linked in. Qt main() sets up lmos
			: and then calls zig main function. Signals in lmos jump to
			: callbacks in Zig
	Minimal Inkscape
		Inkscape becomes just for drawing. Strip out all non-essential functions.
		SVG is the default format. All settings are stored in the SVG for repeatability.
		Although all information is stored in the SVG, it is added by the GUI.
	Geometry Engine
		Calculate shadows from geometries
			Decompose composite geometries to the smallest parts
			Break parts greater than a shadow size using best division algorithm
		For all objects smaller than a shadow width
			Find the biggest remaining object
			Group that object and all objects that can lie within it
			Calculate the leftmost and rightmost shadow edges that could mark those objects
			Find the largest remaining object that fits within those edges but does not lie in both
			Add it to the group and shrink the left or right edge to accommodate
			Repeat
		break any objects larger than a shadow at the best (narrowest?) point and automatically create the shadows
		Calculate shadows
			Sort all objects by start point
			For each object:
				If object falls within a shadow created above then add to that shadow and remove from list. Don't update count
				Calculate end point of shadow started on that object
				Count all objects that lie within that shadow
			Create shadow with largest count
			Remove those objects from list
			Repeat
		Calibrator
			Overview
				: The output of the calibration process is an array of shadows,
				: each comprising the start X coordinate and the width, such that
				: a line broken into individual sections placed into the shadows
				: would result in a single unbroken line.
				: Due to non-circular geometry of the ring, or non-linearity of
				: the rotary axis, the shadows may not meet or may overlap.

Workflows
	Ideal Setup
		GUI with fast access to templates for common jobs and customers, and
		   recording of completed job
		Computer vision and machine learning for fast setup, calibration, and
		  removal of need to open door
		Integration with Inkscape, FreeCAD and blender for immediate
		   visualisation of job and positioning
		Hardware control for fast operation (touchscreen, NuLOOQ, fpga)
	Ideal Workflow
		Unpack item from customer
		In web gui, select item type and customer from database.
		Select type of marking application, e.g. simple text or fingerprint
		GUI shows details of item, setup instructions, requests for measurement
		Gui updates to show instructions on where to put ink and how to position the item in the holder
		Laser uses cameras, machine vision and positioning laser to digitise the item
			Use 3d reconstruction from photos
			: Requires control of all cameras, rotary axis and positioning laser,
			: with ability to coordinate over the network
		Laser marks apriltags on item and cameras examine them to accurately position and calibrate
		A 3d rendering opens up in web gui
			: Requires the ability to construct a 3d representation of an item from the
			: digitised data, the ability to construct a 3d model to display the item,
			: and the ability to texture the item
		A 2d model opens up in web gui or Inkscape, with sample text or fingerprint, and a template recipe for that application type
			: Requires the ability to construct a 2d model of the item, and the ability to
			: unwrap the photographs to a flat bitmap within Inkscape. Also, the
			: ability to generate shadows from the model.
		User manipulates GUI or the Inkscape drawing, with updates in the 3d viewer
		Select dry run in the gui
			: Requires blastpit positioning laser parsing and control.
			: Requires ability to calibrate positioning laser
			: Requires the Blastpit gui to parse recipes from Inkscape
		Check position and modify if necessary
		Use Steam controller to jog
		Select full marking in gui
			: Requires blastpit laser marking and control.
		Positioning laser or camera calculates depth of marking if possible
		Auto take photo of completed job and enter into a database or spreadsheet, with a time entry in the remind calender
			: Requires database connection and better control of Openoffice macros.
	Positioning Help Workflow Example
		Compile list of all geometries that are on visible layers with height
		Exclude any geometries falling outside of 0,0 -> 120,120
		Convert geometries to simplified versions and keep track
		Upload
		Activate positioning help, which should show the bounding box of all paths by default
		NuLOOQ jog wheel cycles through the list of paths, showing simplified outline
		When the centre (II) button is pressed and released, the NuLOOQ changes state:
			The last selected object is now shown in more detail
			NuLOOQ grey ring manipulates the geometry
			Holding a finger on the centre (II) button while rotating the
				grey ring scales inward or outward.
			Jog wheel revolves positioning help around perimeter of shape. By
				default, one circle of the ring corresponds to one circle of
				the perimeter of the shape. Pressing left (I) or right (III)
				decreases or increases the level of detail
			A warning is shown (perhaps flashing leds on NuLOOQ or by showing a rectangular bounding box with a cross through it) if the current
				height (as told by RCU) does not match the layer height. This can
				be caused by attempting to display items with the door open, which
				prevents the height from adjusting automatically. It may be possible to
				manually adjust it
		Pressing the bottom button (O) exits the positioning help, and sends
			back any changes to the geometry.  Use setdimension() to scale the
			width/height, and setposvalues to modify the position and rotation
	Anticipated Workflow Example
		start lmos
		start blastpitgui
		start inkscape
		create drawing
		click apply
		inkscape sends the svg to blastpitgui, which stores it as the blastpit object
		blastpitgui runs the svg2bezier converter
		send to lmos
		listen for positioning changes on the nulooq/steam controller
		convert to geometry translations
		update xml
		when complete, send back to inkscape
		update Inkscape with xdotool
		Receive command to mark
			Analyse geometry for break points
			Create shadows and layers
			Translate recipe
			Upload XML
			Mark geometries
		Auto switch to positioning help when job is done for repetitive jobs, so that we can quickly remove the part and drop the next part in the marked position
	Continuous Rotary Engraving Workflow
		Calculate shadows
			: Each shadow starts at the correct location,
			: but slightly overlaps its end point
		Boolean divide surface at shadow boundaries
		Draw calibration lines
			: Main line is drawn at the start of each shadow
			: Varying lines are drawn in the previous shadow
			: either side of the end point
		Stretch geometries to fit
			: Shrink or stretch the geometries to meet up
			: with the exact start of the next shadow
	Workflow Overview
		Calibration
			[_] Ring calibration line generator with letters/numbers
			[_] Ring calibration decoder and shadow creator
			[_] use positioning laser to scan
				[_] determine height and position
		Shadow Generation
			Generate an array of shadows
				: Layers are shadows. All objects on that layer are marked within that
				: shadow.
			Split geometries at shadow boundaries
			[_] Stagger shadows by number of passes
				This is only needed on seamless drawings, where the joins cannot be avoided. Otherwise, just split at the individual paths.
		[_] Laser a ring from Python (move/resize GalvoGroupShadow101 and repeat. Queue layers up inside the XML and then get lmos to call them in sequence)
			For each layer
				Activate that layer and deactivate all others
				Move the shadow into position
				Start marking
				Wait for finished marking signal
		[_] Cylinder marking, with queued shadows and feedback from lmos signals
		[_] Jupyter control
			Generate SVG for display in Jupyter
			: https://matplotlib.org/gallery/#d-plotting
		[_] Steam controller to manipulate SVG with realtime update
			Think of ways that we can speed up fine-tuning of position
			Allow easy (one-click?) repeat cut and repeat clean,
				(by depressing the main centre button cluster?)
		Job Control
			[_] Modify queue to automatically move to next job once current job ends
			[_] Add recipe parser to automatically put jobs in queue
			[_] Add function to check from log if parent completed successfully
		[_] GNU Octave? Do we use it to do the heavy lifting?
		[_] Recognise (similar to Inkscape recognise plugin)
			: Nearly horizontal/vertical lines
			: Recognise arcs and circles
			: Move items to nearest grid
		[_] need to simulate (blender?) tol text to get height looking good before lasering
		[_] FreeCAD: Model rings (parametrically) and then create jigs to hold them

API Reference
	Recipe Example
		<recipe>
		mark layer1, layer2
		rough using 4 passes with setting silver and hatch standard
		skim using 1 pass with setting cleaning
		mark layer3
		rough using 1 pass with setting silver and hatch standard
		skim using 1 pass with setting fine clean
		</recipe> 
	Class List
		m = method, p = property, l = list
		Blastpit
			Parser
				Network
				Lmos
			Drawing
				mImportSvg (parses SVG and build database)
				mExportSvg (constructs SVG from database)
				pConvex/Concave
				pDiameter
				pJig Angle
				lRecipes
					Recipe
				lShadows
					Shadow
						pZHeight
						pPosition
						pSize
						lPaths
							Path
				lCalibrationMap
					: A calibration map maps a 2d x,y point of the drawing to a 4d
					: x,y,z height, rotation r  point.

Notes for Neovim
	: \cb to create checkbox
	: \cx to toggle
	: \cd to delete

# vim: foldlevel=1 foldcolumn=5 tw=80
