Battle Plan (Read every time)
	Tools (test after every system/neovim update)
		Setup youcompleteme and get it working properly with omnicomplete and snippets
		Setup ctags
		Setup fugitive
		Setup vim debugger
	Overall Design
		Break the task into programs that use STDIN/STDOUT pipes. This enables fuzzing with afl.
	Program Design
		Divide and conquer. Break the programs into functions. Imagine the
		function that you wish existed and write it. Don't worry about
		function call overhead.
	General Design
		You will get it wrong, so optimize for making your code easy to modify
		in the future
	Software Development Principles
		Clean code
		Convert everything to TDD
		Convert as much code to C as possible. Use assertions. Learn the
		standard C library.
		Move away from Qt for library code where possible
	Optimization
		Do less. Do it less often.
	Documentation
		Document the build tools files as well (such as sip files) because we will
		forget how to use them

Coding Roadmap
	[_] Refactor libblastpit as a c library with swig python bindings
		: Rewrite all python code in blastpy as c functions
	[_] Move network code to libblastpit
		: libblastpit will have interface functions that externally link to
		: c++ classes for network.cpp
		[_] Use mqtt instead of Qt Network
			Test List
				[X] Send message to mqtt
				[X] Receive message from mqtt
				[_] Callback on received message
				[_] Send high priority message
		[_] Network feedback and status 
			: Use same code to send and receive, so the network can speak to
			: itself
	[_] Add return codes to all lmosactx calls from lmos, where possible
	[_] Add all return codes and signal return codes to parser log
	[_] Refactor parser to the thinnest shim between blastpit and lmos, put it in lmos.cpp
	[_] Put main parser code in parser
	[_] Full Python control of Lmos
	[_] Steam controller
		Determine best use of keys
	[X] Jupyter
	[_] Ring calibrator
		Calculate shadows from geometries
			Decompose composite geometries to the smallest parts
			Break parts greater than a shadow size using best division algorithm
			Calculate best shadow 
		Draw calibration lines
			Draw long line at end of first shadow
			Extend second shadow backwards to overlap first
			Draw calibration lines across long line
		Calibrate geometry
			

Inkscape Roadmap
	[_] Inkscape break discrete paths into shadow parts where possible to avoid breaks
		For all objects smaller than a shadow width
			Find the biggest remaining object
			Group that object and all objects that can lie within it
			Calculate the leftmost and rightmost shadow edges that could mark those objects
			Find the largest remaining object that fits within those edges but does not lie in both
			Add it to the group and shrink the left or right edge to accommodate
			Repeat
	[_] SVG to Lmos Conversion
		Break inkscape drawing up into individual laserable objects (compound shapes)
		break any objects larger than a shadow at the best (narrowest?) point and automatically create the shadows
		Calculate shadows
			Sort all objects by start point
			For each object:
				If object falls within a shadow created above then add to that shadow and remove from list. Don't update count
				Calculate end point of shadow started on that object
				Count all objects that lie within that shadow
			Create shadow with largest count
			Remove those objects from list
			Repeat
		put objects into shadows (layers)
		for each layer: upload layer objects, start marking, etc.
	[_] Generate and laser a ring from Inkscape SVG Library
		Load Inkscape SVG
		Create objects
			: Line, arc, text, layer, shadow, laser parameter, ring
			: feature
		Export to Rofin XML
		Very fast change to laser parameters/number of passes or layer height from inkscape
		Very visible status within Inkscape - bright colours to show enabled/disabled and laser parameters
			: Maybe use filter so that a change to colour or fill will
			: automatically update.


::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                 Workflows                                  :
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

Ideal Setup
	GUI with fast access to templates for common jobs and customers, and
	   recording of completed job
	Computer vision and machine learning for fast setup, calibration, and
	  removal of need to open door
	Integration with Inkscape, FreeCAD and blender for immediate
	   visualisation of job and positioning
	Hardware control for fast operation (touchscreen, NuLOOQ, fpga)

Ideal Workflow
	Unpack item from customer
		Place in camera view
		Recogniser: Camera recognises item and displays GUI screen to choose customer and item
		: Requires a database of customers and products
	Select type of marking application, e.g. simple text or fingerprint
	GUI shows details of item, setup instructions, requests for measurement
		Can GUI be a web app or emscripten app running in a browser?
	Gui updates to show instructions on where to put ink and how to position the item in the holder
	Laser uses cameras, machine vision and positioning laser to digitise the item
		Use 3d reconstruction from photos
		: Requires control of all cameras, rotary axis and positioning laser,
		: with ability to coordinate over the network
	Laser marks apriltags on item and cameras examine them to accurately position and calibrate
	A 3d rendering opens up in Blender or FreeCAD
		: Requires the ability to construct a 3d representation of an item from the
		: digitised data, the ability to construct a 3d model to display the item,
		: and the ability to texture the item
	A 2d model opens up in Inkscape, with sample text or fingerprint, and a template recipe for that application type
		: Requires the ability to construct a 2d model of the item, and the ability to
		: unwrap the photographs to a flat bitmap within Inkscape. Also, the
		: ability to generate shadows from the model.
	User manipulates the Inkscape drawing, with updates in the 3d viewer
	Select dry run in the gui
		: Requires blastpit positioning laser parsing and control.
		: Requires ability to calibrate positioning laser
		: Requires the Blastpit gui to parse recipes from Inkscape
	Check position and modify if necessary
	Use NuLOOQ to jog
	Select full marking in gui
		: Requires blastpit laser marking and control.
	Positioning laser or camera calculates depth of marking if possible
	Auto take photo of completed job and enter into a database or spreadsheet, with a time entry in the remind calender
		: Requires database connection and better control of Openoffice macros.

Positioning Help Workflow Example
	Compile list of all geometries that are on visible layers with height
	Exclude any geometries falling outside of 0,0 -> 120,120
	Convert geometries to simplified versions and keep track
	Upload
	Activate positioning help, which should show the bounding box of all paths by default
	NuLOOQ jog wheel cycles through the list of paths, showing simplified outline
	When the centre (II) button is pressed and released, the NuLOOQ changes state:
		The last selected object is now shown in more detail
		NuLOOQ grey ring manipulates the geometry
		Holding a finger on the centre (II) button while rotating the
			grey ring scales inward or outward.
		Jog wheel revolves positioning help around perimeter of shape. By
			default, one circle of the ring corresponds to one circle of
			the perimeter of the shape. Pressing left (I) or right (III)
			decreases or increases the level of detail
		A warning is shown (perhaps flashing leds on NuLOOQ or by showing a rectangular bounding box with a cross through it) if the current
			height (as told by RCU) does not match the layer height. This can
			be caused by attempting to display items with the door open, which
			prevents the height from adjusting automatically. It may be possible to
			manually adjust it
	Pressing the bottom button (O) exits the positioning help, and sends
		back any changes to the geometry.  Use setdimension() to scale the
		width/height, and setposvalues to modify the position and rotation

Anticipated Workflow Example
	start lmos
	start blastpitgui
	start inkscape
	create drawing
	click apply
	inkscape sends the svg to blastpitgui, which stores it as the blastpit object
	blastpitgui runs the svg2bezier converter
	send to lmos
	listen for positioning changes on the nulooq/steam controller
	convert to geometry translations
	update xml
	when complete, send back to inkscape
	update Inkscape with xdotool
	Receive command to mark
		Analyse geometry for break points
		Create shadows and layers
		Translate recipe
		Upload XML
		Mark geometries
	Auto switch to positioning help when job is done for repetitive jobs, so that we can quickly remove the part and drop the next part in the marked position

Continuous Rotary Engraving Workflow
	Calculate shadows
		: Each shadow starts at the correct location,
		: but slightly overlaps its end point
	Boolean divide surface at shadow boundaries
	Draw calibration lines
		: Main line is drawn at the start of each shadow
		: Varying lines are drawn in the previous shadow
		: either side of the end point
	Stretch geometries to fit
		: Shrink or stretch the geometries to meet up
		: with the exact start of the next shadow

Workflow Overview
	Calibration
		[_] Ring calibration line generator with letters/numbers
		[_] Ring calibration decoder and shadow creator
		[_] use positioning laser to scan
			[_] determine height and position
	Shadow Generation
		Generate an array of shadows
			: Layers are shadows. All objects on that layer are marked within that
			: shadow.
		Split geometries at shadow boundaries
		[_] Stagger shadows by number of passes
			This is only needed on seamless drawings, where the joins cannot be avoided. Otherwise, just split at the individual paths.
	[_] Laser a ring from Python (move/resize GalvoGroupShadow101 and repeat. Queue layers up inside the XML and then get lmos to call them in sequence)
		For each layer
			Activate that layer and deactivate all others
			Move the shadow into position
			Start marking
			Wait for finished marking signal
	[_] Cylinder marking, with queued shadows and feedback from lmos signals
	[_] Jupyter control
		Generate SVG for display in Jupyter
		: https://matplotlib.org/gallery/#d-plotting
	[_] Steam controller to manipulate SVG with realtime Tripmine update
		Common Python library for both FreeCAD and Inkscape
		[_] auto transfer into inkscape
			Is the 'upload to laser' command necessary?
		[_] Use xdotool to automatically reload the preview in Inkscape
		Think of ways that we can speed up fine-tuning of position
		Allow easy (one-click?) repeat cut and repeat clean,
			(by depressing the main centre button cluster?)
	Job Control
		[_] Modify queue to automatically move to next job once current job ends
		[_] Add recipe parser to automatically put jobs in queue
		[_] Add function to check from log if parent completed successfully
	[_] GNU Octave? Do we use it to do the heavy lifting?
	[_] Recognise (similar to Inkscape recognise plugin)
		: Nearly horizontal/vertical lines
		: Recognise arcs and circles
		: Move items to nearest grid
	[_] Import and Export FreeCAD
	[_] Acam to SVG
	[_] SVG to acam
	[_] OpenCV + Zbar for qrcode recognition
	[_] Get camera working on linux
	[_] need to simulate (blender?) tol text to get height looking good before lasering
	[_] FreeCAD: Model rings (parametrically) and then create jigs to hold them

Inkscape Workflow
	Start inkscape
	Run 'laser' extension that runs in background
	Select 'apply'
	Extension runs 
		Fires up blastpit gui
		automatically uses xdotool to minimize and refresh itself
	Blaspit gui
	Get inkscape to dry run a ring
		Then create a calibrator which creates a ring dry run set of geometries
		Then create a calibrator that modifies the dry run geometries to fit the ring
		run dry run again to see that things are ok
		Run the calibrator a second time but on the actual geometries
		Run the dry run with the new modified geometries
		Run the actual thing.
	Dry run a ring
		For each shadow, create a layer
		Put all geometries to be marked within that shadow on that layer
		Upload

Detailed Code Workflow
	Network -> Send packet to other Network
	Network receives packet, stores it and replies ack/nack based on checksums.
	Network passes to parser
	Parser checks if new command is waiting on old command to finish
	If so, parser sets signal/slot to wake up on lmos message, and returns
		: Not neccesary. The parser should be called by a signal/slot after every
		: command completion.
	Parser calls Lmos
	Lmos runs command and returns to parser
	Parser stores reply in Log class and emits logEntry(id) signal
	Parser sends reply to Network 
	Network sends reply back to caller on same connection
	Note: Parser calls Lmos, and can block without issue because Network will queue packets while waiting.
	Network cannot be allowed to block until parser finishes, because parser may hit long-running lmos?
	Clients can call getLogEntry(id) to check if their command has completed successfully.
	Log object: Stores every network packet id, along with 

Project Component List
	Cgal/Ipython for boundaries/hatching/offset etc
	Blender
	Postgres for big data
	Acam
		: Basic plugin to send and receive drawing data from the tentacle
		: server
	Blastpit
		: Geometry, SVG, network and Octave library. The blastpit class
		: contains an SVG document that holds all geometries and settings.
	FreeCAD
	Inkscape
	BlastpitGui
		: NuLOOQ driver, compute engine and input/output forms. Contains an
		: instance of the blastpit class to hold the current job.
	LMOS
		: LMOS driver. Should be as simple as possible - all computation done
		: on the blastpitgui server.
	Laser Controller (bplaser)
		Initialise systray
		Initialise laser
			: Create the laser object and pass a pointer to the network class
			: which will listen for commands from the server and send them to
			: the LMOS control
		Initialise cameras
		Network server
			Create socket
			Listen for connection (signal/slot)
			ReceiveCommand (wait for command + data)
				: Allocate buffer to hold command (uint16)
				: Read 2 bytes from socket (implement generic read command)
				: Parse the command
				: Call a function based on the command (function pointer?)
				: * the function can use get + put commands to speak
				: a dialogue with the client until the command is complete.
				InitMachine
				ClearLayout
				ImportXMLFile
				StartPosHelp
				StopPosHelp
				StartMarking
				StopMarking
				NewPos
				MoveAxes
				(camera) Capture image
			Send reply
				Return data
				Inform blastpit server of current state of laser and hardware
					state = GetLaserStatus()
					SendServer( state )
	Recogniser
		Recognises item from image
			Input: CV dataset, Bitmap from camera
			Output: Table of confidence that item is within dataset
			Output: Position and orientation of item
	GUI
		Allows choice of item, customer
			Input: Manual drop-down box / External signal from recogniser
			Input: Manual measurement of item / Laser digitised measurement
			Output: GUI information about item
			Output: FreeCAD or Blender 3D model real-time update
			Output: Inkscape 2D model real-time update
	Calibrator
		Overview
			The output of the calibration process is an array of shadows, each comprising the start X coordinate and the width, such that a line broken into individual sections placed into the shadows would result in a single unbroken line.
			Due to non-circular geometry of the ring, or non-linearity of the rotary axis, the shadows may not meet or may overlap.


::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:                                   Theory                                   :
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

Theory
	Test Driven Development
		Software TDD
			What is the set of tests which, when passes, demonstrates that the code works correctly?
			What are the requirements to test 'x'? 
				What does the object do?
				How does it interact with the data or hardware it controls?
				How can we make it testable?
			When writing a test, imagine the perfect interface for that function
				What function do we wish existed
			Write a test list
			Fundamentals
				Test harness contains features
				Unit tests test those features
				Tests test against the feature requirements, not against the code structure
			Write a test
			Check that it fails but existing tests pass
			Write code
			Check that all tests now pass
			Clean up code
			Fuzz using AFL
		Hardware TDD
			Create a thin layer that works against the actual hardware, and test it against the hardware to ensure that it works.
			Create a mock that has the same functions and interface as the thin layer.
	Optimization
		There are only three optimizations: Do less. Do it less often. Do it faster. The largest gains come from 1, but we spend all our time on 3.

API Reference
	Recipe Example
		<recipe>
		mark layer1, layer2
		rough using 4 passes with setting silver and hatch standard
		skim using 1 pass with setting cleaning
		mark layer3
		rough using 1 pass with setting silver and hatch standard
		skim using 1 pass with setting fine clean
		</recipe> 
	Class List
		m = method, p = property, l = list
		Blastpit
			Parser
				Network
				Lmos
			Drawing
				mImportSvg (parses SVG and build database)
				mExportSvg (constructs SVG from database)
				pConvex/Concave
				pDiameter
				pJig Angle
				lRecipes
					Recipe
				lShadows
					Shadow
						pZHeight
						pPosition
						pSize
						lPaths
							Path
				lCalibrationMap
					: A calibration map maps a 2d x,y point of the drawing to a 4d
					: x,y,z height, rotation r  point.

Class Relationship
	Blastpit contains Network, Parser, Drawing
	Network contains Mqtt 
	Drawing contains Xml

Testing Hierachy
	blastpy
		libblastpit
			network
					mqtt
			parser
			drawing

Notes for Neovim
	: \cb to create checkbox
	: \cx to toggle
	: \cd to delete

# vim: foldlevel=1 foldcolumn=5
